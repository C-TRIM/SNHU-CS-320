README.md

# CS 320 Portfolio Submission

## Overview
This repository contains my portfolio artifacts for **CS 320: Software Testing, Automation, and Quality Assurance**.  
It includes work from Project One and Project Two, demonstrating my ability to design unit tests, analyze requirements, and apply testing strategies to ensure functional, reliable, and secure software.

---

## Artifacts

### Project One
- `Contact.java`  
- `ContactService.java`  
- `ContactTest.java`  
- `ContactServiceTest.java`  

These files show my ability to implement object-oriented design and create JUnit tests that verify functionality, boundary conditions, and error handling.

### Project Two
- **Summary and Reflections Report**  

This report reflects on the testing approaches I used, such as black box testing and boundary value analysis, and explains how my tests aligned with requirements to achieve strong code coverage.


Reflection

How can I ensure that my code, program, or software is functional and secure?
I ensure functionality and security by writing unit tests that verify program behavior, running automated test suites to catch errors, and reviewing my code for potential vulnerabilities. I also apply secure coding practices such as input validation and exception handling to minimize risks. Testing early and often helps me confirm that the application works as intended while protecting sensitive data.

How do I interpret user needs and incorporate them into a program?
I start by carefully reviewing the requirements provided by the client or end user. I break them down into specific features and constraints, then translate them into code and test cases. Writing tests based on requirements ensures that user needs drive the development process and that the final product meets expectations.

How do I approach designing software?
I use an iterative approach, beginning with analyzing the problem and defining requirements. I then create a design that breaks the program into logical components or classes. My design focuses on simplicity, reusability, and maintainability. By combining object-oriented principles with test-driven development, I build software that is both functional and easy to update in the future.
